# 面试题

## 基础

### 1. `String`、`StringBuffer`、`StringBuilder`的区别

`String`字符串常量

`StringBuffer`字符串变量（线程安全）

`StringBuilder`字符串变量（非线程安全）

`StringBuffer`对方法加了同步锁或者对调用的方法加了同步锁，所以线程是安全的

`StringBuilder`并没有对方法进行加同步锁，所以是非线程安全的

使用方面：

如果要操作少量的数据用`String`

多线程操作字符串缓冲区下操作大量数据用`StringBuffer`

单线程操作字符串缓冲区下大量数据用`StringBuilder`

### 2. 重写和重载的区别

重写：发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同。

重载：发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类，如果父类方法的访问修饰符用的private
则子类不能重写这个方法。

### 3. `==`和`equals`的区别

`==`一般比较基本类型，比较的就是值是否相同，引用类型比较的就是地址值是否相同

`equals`比较的是内容，而不是地址值，比如`String`，`Integer`这些类中都是重写了`equals`

### 4. 接口和抽象类的区别

首先是实现，抽象类用`extends`继承，接口必须是`implements`实现

然后是构造函数：抽象类可以又构造函数，接口不能。

实现数量，类可以实现多个接口，但是不能继承多个抽象类

访问修饰符：接口中的方法默认使用`public`修饰，抽象类中的方法可以是任意修饰符

### 5. 什么是`B/S`架构，什么是`C/S`架构

`B/S` 浏览器服务器程序

`C/S` 客户端/服务端 桌面应用程序

### 6. `java`的数据结构有哪些

1. 线性表`（arraylist)`
2. 链表`（LinkedList）`
3. 栈`（Stack）`
4. 队列`（Queue）`
5. 图`（Map）`
6. 树`（Tree）`

### 7. java中有几种数据类型

整形：`byte`，`short`，`int`，`long`

浮点型：`float`，`double`

布尔型：`boolean`

字符型：`char`

### 8. 什么是单例模式

某个类的实例在多线程环境下只会被创建一次

单例模式有饿汉式和懒汉式还有双检锁三种

饿汉式的线程安全，一开始就初始化

懒汉式线程不安全，延迟初始化

双检锁线程安全，延迟初始化

### 9. 异常

`Throwable`是所有`java`程序中错误处理的父类，有两种职类：`Error`和`Exception`

`Error`表示由`JVM`所侦测到的错误，由于`JVM`层次的严重错误，导致`JVM`无法继续执行。

`Exception`表示可恢复的异常，这是可以处理的

比如运行时异常和编译时异常

运行时异常比如空指针异常，索引越界异常等

编译时异常比如语法异常，等等

### 10. `BIO` `NIO` `AIO`的区别

`BIO`：`Block IO`同步阻塞式`IO`，就是我们平时使用的传统`IO`，他的特点是简单使用方便，并发处理能力低

`NIO`：`New IO `同步非柱塞`IO`，是传统`IO`的升级，客户端和服务端通过通道通讯，实现了多路复用

`AIO`：也叫`NIO2`，是`NIO`的升级，实现了异步非柱塞`IO`，异步`IO`的操作基于事件和回调机制

### 11. `ThreadLocal`的原理

`ThreadLocal`：为共享变量在每一个线程中创建一个副本，然后每个线程都可以访问内部的副本变量。通过`threadlocal`保证线程的安全性。

其实在`Threadlocal`类中有一个`ThreadLocalMap`其类似`Map`的内部类，用键值对的形式存储每一个线程的变量副本，ThreadLocalMap中的元素的`key`为当前`ThreadLocal`对象，而`value`对应线程的变量副本。

`ThreadLocal`本身并不存储值，它只是作为一个`key`保存到`ThreadLocalMap`中，但是这里要注意的是它作为一个`key`用的是弱引用，因为没有强引用链，弱应用在`GC（垃圾回收机制）`的时候可能会被回收，这样就会在`ThreadLocalMap`中存在一些`key`为`null`的键值对，因为`key`变成了`null`，但是它本身是不会被清除的，如果没有手动删除对应的`key`就会导致这块内存即不会回收，也无法访问，也就是内存泄漏。
使用玩`threadLocal`之后，记得调用`remove`方法，在不适用线程池的前提下，即使不调用`remove`方法，线程的变量副本也会被`gc`回收，就不会造成内存泄漏

### 12. 同步锁，死锁，乐观锁，悲观锁

同步锁：当多个线程同时访问同一个数据时，很容易出现问题，所以为了避免这种情况，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。`java`中可以使用`synchronized`关键字取得一个对象的同步锁.

死锁：就是多个线程同时阻塞，他们中的一个或者全部都在等待某个资源被释放

乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下再次期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。

悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样被人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程）

### 13. synchronized底层实现原理

synchronized可以保证在同一时刻只有一个方法可以进入临界区，同时它还可以保证共享变量的内存可见性。

java中每一个对象都可以作为锁

synchronized实现同步的基础是，普通同步方法，锁是当前实例对象，静态同步方法，锁是当前类的class对象，同步方法块，锁是括号里的对象

### 14. synchronized和volatile的区别

volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从内存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。

volatile仅能使用在变量级别，synchronized则可以使用在变量，方法，类的级别上

volatile仅能使用在变量的修改可见性，不能保证原子性，而synchronized则可以保证变量的修改可见性和原子性

vloatile不会造成线程的阻塞，synchronized可能会造成线程的阻塞

volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化

### 15. synchronized和lock有什么区别

首先synchronized是java内置关键字，在jvm层面，lock是一个java类

synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁

synchronized会自动释放锁，lock需要手动释放锁，否则容易造成死锁。

用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2等待，如果线程1阻塞，则线程2会一直等待下去，而lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一致等待就结束了。

synchronized的锁可重入，不可中断，非公平，而lock锁可重入，可判断，可公平。

lock锁适合大量同步代码的同步问题，synchronized锁适合代码少量的同步问题。