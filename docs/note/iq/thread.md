# 线程

### 1. 线程和进程的区别

进程是操作系统分配资源的最小单位，是一个正在执行的程序；而线程是进程中一个执行流，是CPU调度和分配的最小单位。

### 2. run和start的区别？

start方法是用来启动一个新线程，start方法在调用的时候会自动调用run方法，而且会在新的线程中运行，而run方法是线程的执行体，当线程被启动时，run方法会在当前线程中执行。

### 3.创建线程的几种方式？

1. 继承Thread类，重写run()方法。
2. 实现Runnable接口，重写run()方法。
3. 实现callble接口，重写call()方法。

### 4. java中用到的线程调度算法是什么？

抢占式，一个线程用完之后，操作系统会根据线程优先级，线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

### 5. 为什么使用线程池？

首先是提高系统性能，因为线程的创建和销毁是一个比较耗资源的过程，而线程池呢，可以重复利用以创建的线程，然后呢是这个线程池可以限制并发线程的数量，防止系统资源被耗尽。

### 6.线程池的工作原理？

首先我们在提交一个任务的时候，线程池会先去判断当前线程数是不是小于这个核心线程数，如果小于核心线程数，那么就会直接执行任务，如果大于或者等于核心线程数了，那么就会将这个任务放到这个任务队列中等待执行，如果这个时候队列满了，而且正在运行的线程量小于最大线程数，那么还是要创建非核心线程立即运行这个任务，如果队列满了，而且正在运行的线程数量大于或等于最大线程数的收，那么就会抛出拒绝执行的异常。当一个线程无事可做的时候，超过一定的时间，并且运行的线程大于或等于核心线程数，那么就会停掉这个线程。

### 7. 线程池的重要参数

1. 核心线程数
2. 最大线程数
3. 多余线程的存活时间
4. 时间单位
5. 缓冲队列
6. 线程工厂
7. 拒绝策略

### 8. 如何创建线程池？

首先是创建线程池对象，可以使用ThreadPoolExecutor类创建一个线程池对象，指定这个线程池的大小等等，然后使用submit()或execute()方法提交任务到线程池中。

### 9.Synchronized的作用范围？

用在方法上，锁住的是对象的实例。

用在静态方法时，锁住的class实例。

用在一个对象实例上，锁住的是所有以该对象为锁的代码块。

### 10.什么是死锁，如何避免死锁？

一般是两个或者多个线程在互相等待对方释放资源，导致所有的线程被阻塞，无法继续执行的情况。

如何避免死锁呢

我们可以尽量避免线程在等待锁资源时形成循环等待的情况。

### 11.线程池的状态有哪些？

1. RUNNING：线程池处于正常运行状态，可以接收新的任务。
2. SHUTDOWN：线程池处于关闭状态，不会接收新的任务。
3. STOP：线程池处于停止状态，不会接收新的任务，也不会执行任务队列中的任务，正在执行的任务也会被中断。
4. TIDYING：线程池正在关闭，并且正在执行关闭操作。
5. TERMINATED：线程池已经关闭，并且所有任务已经执行完毕。

### 12.线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？

线程池被创建后没有任务过来，里面是不会有线程的，如果需要预热的话可以调用prestarAllCoreThreads和prestarCoreThread方法。

### 13.核心线程和非核心线程的销毁机制？

核心线程默认不会销毁，非核心线程要等到keppAliveTime后才会销毁。

### 14.线程池内抛出异常，线程池会怎么办？

线程池会将这个线程从线程中移除。

### 15. submit和execute方法的区别？

首先在线程池中，这个submit和execute都是提交任务的方法，他们的返回值和参数类型是有区别的，execute只接受Runnable类型的任务，而submit是接收Runnable和Collable类型的任务，返回值上他们的区别是，submit有返回值，而execute没有返回值，并且submit方法更方便对异常的处理。  

### 16.线程池如何重用线程的？

当工作线程数小于核心线程数，那些空闲的核心线程再去队列中取任务的时候，如果队列中的任务数量为0，那么就会阻塞当前线程，这样线程就不会回收了。

### 17. 线程池大小如何设定？

线程池的大小我们需要根据应用场景和硬件环境来确定，一般需要考虑CPU的核心数，内存占用，平均响应时间。

比如线程池不要大于CPU的核心数，这样可以充分利用CPU资源，还要考虑内存占用，每个线程都需要一定的内存资源，还有就是平均响应时间，如果线程池过小，会导致任务排队等待，增加任务的响应时间。

### 18. 线程池是如何实现的？

1. 线程池管理器
2. 工作线程
3. 任务队列
4. 任务接口

### 19. 线程池在实际项目中的使用场景？

线程池一般用于执行多个不关联的耗时任务，并且可以让多个不相关的任务同时执行。

### 20. 说一下synchronized的实现原理？

在java中，每个对象都隐式包含了一个monitor（监视器）对象，加锁的过程其实就是竞争monitor的过程，当线程进入字节码monitorenter指令之后，线程将持有了monitor对象，执行monitorexit时释放monitor对象，当其他线程没有拿到monitor对象时，则需要阻塞等待获取该对象。

### 21. sleep和wait的区别？

sleep用于使当前线程暂停一段时间，等待指定时间后再继续执行，但是在这期间，他不会释放锁。

而wait是Object类中的方法，用于使当前线程暂停执行，等待其他线程调用此对象的notify或者notifyAll方法来唤醒它，在这期间，他会释放掉锁。

### 22.synchronized和volatile的区别？

volatile关键字是线程同步的轻量级实现，所以性能要比synchronized要好，但是volatile关键字只能用于变量，而synchronized关键字可以修饰方法以及代码块,多线程下volatile不会发生阻塞，而synchronized可能会发生阻塞，volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。

### 23. synchronized和lock的区别？

synchronized呢，他是一种悲观锁的机制，而Lock呢是一种乐观锁机制，lock比synchronized更强调锁的概念，并且Lock需要手动去加锁和解说，通过lock.lock()方法进行加锁，通过lock.unlock解锁。

### 24. java中都有哪些锁？

1. 悲观锁

   悲观锁就是认为自己在使用这个数据的时候一定会有别的线程来修改这个数据，所以在获取数据的时候会先加锁，确保这个数据不会被其他的线程修改。

2. 乐观锁

   乐观锁呢认为自己使用数据的时候不会有其他的线程来修改这个数据，所以不会添加锁，但是他会在更新数据的之前去判断一下有没有别的线程修改了这个数据。

3. 自旋锁

   自旋锁就是当一个线程在获取锁的时候，如果锁已经被其他线程获取了，那么该线程将进入循环等待，然后不断的判断锁是否能成功获取了，知道获取到锁才会退出循环。

4. 读写锁

   读写锁是一种特殊的锁，它允许多个线程同时读取共享资源，但是只允许一个线程写入共享资源，它一般用于读多写少的场景，可以提高程序的并发性能。

5. 可重入锁和非可重入锁

   可重入锁就是当一个线程获取锁后，，可以再次获取该锁而不会被阻塞，而且每次获取锁都要对应释放锁。

   非可重入锁就是一种不允许同一个线程多次获取同一个锁的锁机制，当一个线程获取锁后，如果再次获取该锁，就会被阻塞，知道其他线程释放该锁。

### 25. Thread和Runnable的区别？

Thread是一个类，而Runnable是一个接口，还有他们的方法不一样，Thread类有一些自己的方法，例如start()，sleep()等，而Runnable接口只有一个run()方法，要执行任务需要将其传递给Thread对象。